//===---- X86CFI.cpp - kCFI LLVM IR analyzes and transformation -----------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// Uses CFG generated by CodeGen/CFI.cpp to instrument machine code with CFI
// checks that will enforce control-flow
//
// To work correctly, this pass must be applied after the CFI IR pass.
//
//===----------------------------------------------------------------------===//
// TODO:
// * Implement register scavenger function
//   - currently: lots of duplicated code for scavenging registers.
//
// * Reimplement call instruction/type identification heuristics
//   - currently: done through analysing its operators
//   - can be less but this code is confusing and straight-forward

#include <fstream>
#include <iostream>
#include <string>
#include <sstream>
#include <list>

#include "X86ISelLowering.h"
#include "Utils/X86ShuffleDecode.h"
#include "X86CallingConv.h"
#include "X86InstrBuilder.h"
#include "X86MachineFunctionInfo.h"
#include "X86InstrBuilder.h"
#include "llvm/CodeGen/LivePhysRegs.h"
#include "X86TargetMachine.h"
#include "X86TargetObjectFile.h"
#include "X86MachineFunctionInfo.h"
#include "llvm/CodeGen/MachineInstr.h"
#include "llvm/CodeGen/RegisterScavenging.h"
#include "llvm/CodeGen/MachineModuleInfo.h"
#include "X86.h"
#include "X86InstrInfo.h"
#include "X86Subtarget.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/CodeGen/LiveVariables.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/Passes.h"
#include "llvm/CodeGen/CFGforCFI.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Target/TargetInstrInfo.h"
using namespace llvm;

extern cl::opt<bool> CFINoChecks;
extern cl::opt<bool> DisableCFI;
extern cl::opt<bool> CFICGD;
extern cl::opt<bool> CFICoarse;
extern cl::opt<bool> CFIWhiteList;
extern cl::opt<bool> CFIBuildCFG;
extern cl::opt<bool> CFIFwd;
extern cl::opt<bool> CFIv;
extern cl::opt<bool> CFIvv;
extern std::list<std::string> ICallsWhiteList;
extern std::list<std::string> RetsWhiteList;
extern CFICFG cfi;
extern CFIUtils u;
extern std::stringstream cfi_warn;

unsigned CFIReg = X86::R11;

#define DEBUG_TYPE "CFIInstrumentation"

namespace {
  class CFIInstrumentation : public MachineFunctionPass {
    static char ID;

  public:
    CFIInstrumentation() : MachineFunctionPass(ID) {}

    bool runOnMachineFunction(MachineFunction &Fn) override;

    bool isLeaf(MachineFunction &Fn);

    bool bypassList(MachineFunction &Fn);

    void leafPrologue(MachineFunction &Fn);

    void leafEpilogue(MachineFunction &Fn, MachineBasicBlock &MBB);

    void doCalls(MachineFunction &Fn);

    void doCallsCoarse(MachineFunction &Fn);

    void doRets(MachineFunction &Fn, MachineFunction::iterator FI,
                MachineBasicBlock &MBB);

    void doRetsCoarse(MachineFunction &Fn, MachineFunction::iterator FI,
                MachineBasicBlock &MBB);

    void BuildCFG(MachineFunction &Fn);

    void placeTag(MachineBasicBlock::iterator MI_I, MachineBasicBlock &MBBx,
                  DebugLoc DL, MachineFunction &Fn, unsigned int cfitag);

    std::list<int> isWL(std::list<std::string>, std::string fname);

    bool shouldSkip(std::list<int> SkipList, int SkipN);

    MachineBasicBlock* getOrAddRCFIErrorMBB(MachineFunction &Fn);

    MachineBasicBlock* getOrAddCCFIErrorMBB(MachineFunction &Fn);

    void addSecondaryCFICheck(MachineFunction &Fn, MachineBasicBlock* GuardMBB1,
                              MachineBasicBlock::iterator MBBI,
                              MachineBasicBlock* GuardMBB2, unsigned Tag,
                              unsigned Offset);

    const char *getPassName() const override {
      return "X86 CFI Instrumentation";
    }

  private:
    MachineFunction *Fn;
    const TargetMachine *TM;
    const X86InstrInfo *TII;
  };
  char CFIInstrumentation::ID = 0;
}

FunctionPass *llvm::createCFIInstrumentation(){return new CFIInstrumentation();}

bool CFIInstrumentation::runOnMachineFunction(MachineFunction &Fn) {
  int Rets = 0;
  std::list<int> RetSkips;
  bool leaf;

  if(bypassList(Fn)) return true;

  if(CFIBuildCFG){
    BuildCFG(Fn);
    return true;
  }

  if(CFICoarse){
    doCallsCoarse(Fn);

    for(MachineFunction::iterator I = Fn.begin(), E = Fn.end(); I != E; ++I){
      if((!I->empty()) && I->back().isReturn()){
        Rets++;
        if(CFIWhiteList){
          RetSkips = isWL(RetsWhiteList, Fn.getName());
          if(RetSkips.size() > 0 && shouldSkip(RetSkips, Rets))
            continue;
        }
        doRetsCoarse(Fn, I, *I);
      }
    }
    return true;
  }

  leaf = isLeaf(Fn);
  if(CFIFwd){
    if(leaf) leafPrologue(Fn);
    else doCalls(Fn);
  }

  for(MachineFunction::iterator I = Fn.begin(), E = Fn.end(); I != E; ++I){
    if((!I->empty()) && I->back().isReturn()){
      Rets++;
      if(CFIWhiteList){
        RetSkips = isWL(RetsWhiteList, Fn.getName());
        if(RetSkips.size() > 0 && shouldSkip(RetSkips, Rets))
          continue;
      }
      if(leaf) leafEpilogue(Fn, *I);
      else doRets(Fn, I, *I);
    }
  }
  return true;
}

bool CFIInstrumentation::bypassList(MachineFunction &Fn){
  StringRef fname = Fn.getName();
  if(fname.equals_lower("call_violation_handler")) return true;
  if(fname.equals_lower("ret_violation_handler")) return true;
  if(fname.equals_lower("asm_violation_handler")) return true;
  if(fname.equals_lower("mcount")) return true;

  return false;
}

void CFIInstrumentation::BuildCFG(MachineFunction &Fn){
  MachineModuleInfo &MMI = Fn.getMMI();
  const Module *M = MMI.getModule();
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  DebugLoc DL;
  const TargetInstrInfo &TII = *STI.getInstrInfo();

  const Function *F = Fn.getFunction();

  MachineFunction::iterator Entry = *Fn.begin();
  MachineBasicBlock::iterator MI_I;
  while(Entry->empty()){
    Entry++;
    if(Entry == Fn.end()){
      cfi_warn << "Empty function found: " << Fn.getName().str() << "\n";
      u.warn();
      return;
    }
  }
  MI_I = Entry->begin();

  DL = MI_I->getDebugLoc();
  MachineInstrBuilder MIB;

  unsigned int n = F->getCFINode();

  // Older version used movl instructions to tag code, kcfi-tools is not yet
  // compatible with nopl tags. Yet, building a CFG with movl is harmless.
  // TODO: Fully support nopl tags on kcfi-tools and remove movl tags below
  if(CFINoChecks){
    MIB = BuildMI(*Entry, MI_I, DL, TII.get(X86::NOOPL))
      .addReg(0)
      .addImm(1)
      .addReg(0)
      .addImm(n)
      .addReg(0);
  } else {
    MIB = BuildMI(*Entry, MI_I, DL, TII.get(X86::MOV32mi))
      .addReg(0)
      .addImm(1)
      .addReg(0)
      .addGlobalAddress(M->getNamedValue("global_signature"))
      .addReg(0)
      .addImm(n);
  }
}

bool CFIInstrumentation::isLeaf(MachineFunction &Fn){
  MachineFunction::iterator MBB_I, MBB_IE;
  MachineBasicBlock::iterator MI_I, MI_IE;
  const Function *F;
  CFINode n;

  // check if the function is empty first;
  MBB_I = *Fn.begin();
  while(MBB_I->empty()){
    MBB_I++;
    if(MBB_I == Fn.end()) return false;
  }

  F = Fn.getFunction();
  n = cfi.getNode(F->getCFINode());
  if (n.leaf_distance > 0) return false;

  return true;
}

void CFIInstrumentation::leafPrologue(MachineFunction &Fn){
  MachineInstrBuilder MIB;
  MachineFunction::iterator Entry = *Fn.begin();
  MachineBasicBlock::iterator MI_I;
  DebugLoc DL;
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const X86RegisterInfo *RegInfo = STI.getRegisterInfo();
  unsigned BasePtr = RegInfo->getStackRegister();

  unsigned Mov;
  if(STI.is64Bit()){
    Mov = X86::MOV64rm;
  } else {
    Mov = X86::MOV32rm;
  }

  MI_I = Entry->begin();
  MIB = BuildMI(*Entry, MI_I, DL, TII.get(Mov), CFIReg);
  addRegOffset(MIB, BasePtr, false, 0);
  MIB.getInstr()->setCFIFlag(MachineInstr::CFIPrologue);
  fprintf(stderr, "prologue\n");
}

void CFIInstrumentation::leafEpilogue(MachineFunction &Fn,
                                      MachineBasicBlock &MBB){
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const X86RegisterInfo *RegInfo = STI.getRegisterInfo();
  unsigned BasePtr = RegInfo->getStackRegister();
  DebugLoc DL;
  const TargetInstrInfo &TII = *STI.getInstrInfo();

  unsigned Mov;
  if(STI.is64Bit()){
    Mov = X86::MOV64mr;
  } else {
    Mov = X86::MOV32mr;
  }

  MachineInstrBuilder MIB;
  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();

  MIB = BuildMI(MBB, MBBI,DL, TII.get(Mov));
  addRegOffset(MIB, BasePtr, false, 0).addReg(CFIReg);
  MIB.getInstr()->setCFIFlag(MachineInstr::checkTag);

  MBBI->setCFIFlag(MachineInstr::checkedRet);
  fprintf(stderr, "epilogue\n");
}

void CFIInstrumentation::doCalls(MachineFunction &Fn){
  MachineModuleInfo &MMI = Fn.getMMI();
  const Module *M = MMI.getModule();
  StringRef fname = Fn.getName();
  int TagOffset = -4;
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  DebugLoc DL;
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  bool PtrCall = true;
  bool IndirectCall = false;
  bool ShouldKill;
  bool HasWL = false;
  unsigned Dst = 0;
  unsigned NumParms = 1;
  unsigned ICalls = 0;
  unsigned int CFIHid = 0, CFITid = 0;
  CFINode n;

  std::list<int> ICallSkips;
  std::list<int>::iterator skip_it;

  if(CFIWhiteList){
    ICallSkips = isWL(ICallsWhiteList, fname);
    if(ICallSkips.size() > 0) HasWL = true;
  }

  MachineBasicBlock::iterator MI_I, MI_IE;
  MachineFunction::iterator MBB_I, MBB_IE;
  MachineFunction::iterator Entry = *Fn.begin();
  while(Entry->empty()){
    Entry++;
    if(Entry == Fn.end() && CFIv){
      cfi_warn << "Empty function found: " << fname.str() << "\n";
      u.warn();
      return;
    }
  }
  MI_I = Entry->begin();

  unsigned Movrm;
  if(STI.is64Bit()){
    Movrm = X86::MOV64rm;
  } else {
    Movrm = X86::MOV32rm;
  }

  // prologue tags are placed in CodeGen/AsmPrinter
  MachineInstrBuilder MIB;

  for(MBB_I = Fn.begin(), MBB_IE = Fn.end(); MBB_I != MBB_IE; MBB_I++) {
    MachineBasicBlock &MBB = *MBB_I;
    for(MI_I = MBB.begin(), MI_IE = MBB.end(); MI_I != MI_IE; MI_I++) {
      MachineInstr &MI = *MI_I;
      unsigned Opc = MI.getOpcode();

      if(MI.isCall() && MI.getCFIFlag() != MachineInstr::checkedCall){
        DL = MI.getDebugLoc();
        IndirectCall = false;
        PtrCall = true;
        ShouldKill = false;
        NumParms = 1;
        unsigned int NumOps = MI.getNumOperands();

        // identify how the call is made and set for building later cfi checks
        // note: this heuristics can certainly receive some love (refactoring)
        if(NumOps > 0){
          MachineOperand Op = MI.getOperand(0);
          if(Op.isSymbol()){
            std::string s = Op.getSymbolName();
            // some symbols need special handling
            if(s.compare("memcpy")==0){
              CFINode n = cfi.getAsmNode("__memcpy");
              placeTag(MI_I, MBB, DL, Fn, n.tail_id);
              MI.setCFIFlag(MachineInstr::checkedCall);
              continue;
            }
            if(s.compare("memset")==0){
              CFINode n = cfi.getAsmNode("__memset");
              placeTag(MI_I, MBB, DL, Fn, n.tail_id);
              MI.setCFIFlag(MachineInstr::checkedCall);
              continue;
            }
            cfi_warn << "UNHANDLED SYMBOL: " << s << " ";
            cfi_warn << Fn.getFunction()->getParent()->getName().str() << "\n";
            u.warn();
            continue;
          };
          if(Op.isGlobal()){}
          else if(Op.isReg()){
            Dst = Op.getReg();
            IndirectCall = true;
            if(Opc == X86::CALL64m || Opc == X86::CALL32m){
              Op = MI.getOperand(2);
              NumParms = 5;
            } else if(MI.getOpcode() == X86::TAILJMPm64){
              continue;
            } else {
              PtrCall = false;
              NumParms = 1;
            }
          } else if(Op.isFI()){
            IndirectCall = true;
            NumParms = 5;
          } else if(NumOps >= 2 && MI.getOperand(2).isReg()
                    && MI.getOperand(3).isGlobal()){
            Op = MI.getOperand(2);
            Dst = Op.getReg();
            IndirectCall = true;
            NumParms = 5;
          }
        }

        CFICluster c = cfi.getCluster(MI.getCFITag());
        if(c.id){
          CFIHid = c.head_id;
          CFITid = c.tail_id;
        } else {
          n = cfi.getNode(MI.getCFITag());
          CFIHid = n.head_id;
          CFITid = c.tail_id;
        }

        // instrument indirect calls
        if(IndirectCall && !CFINoChecks) {
          if(CFIHid == 0){
            cfi_warn << Fn.getFunction()->getParent()->getName().str() << "\n";
            u.warn();
            u.error("Tag = 0! (possible kCFI front-end error)", true);
          }

          // if call is whitelisted, just tag return and continue to next
          ICalls++;
          if(HasWL && shouldSkip(ICallSkips, ICalls)){
            MI.setCFIFlag(MachineInstr::checkedCall);
            placeTag(MI_I, MBB, DL, Fn, CFITid);
            MI_I = MBB.begin();
            continue;
          }

          if(PtrCall){
            // create MOV instruction
            MIB = BuildMI(MBB, MI_I, DL, TII.get(Movrm), CFIReg);

            for(unsigned i = 0; i < MI.getNumOperands() && i < NumParms; i++){
              MIB.addOperand(MI.getOperand(i));
              // regs are used by the next call. unset kill.
              if(MIB.getInstr()->getOperand(i).isReg()
                 && !MIB.getInstr()->getOperand(i).isDef())
                MIB.getInstr()->getOperand(i).setIsKill(false);
            }
            Dst = CFIReg;
            ShouldKill = true;
          }

          // Create CMP instruction
          MIB = BuildMI(MBB, MI_I, DL, TII.get(X86::CMP32mi));
          addRegOffset(MIB, Dst, ShouldKill, TagOffset);
          MIB.addImm(CFIHid);
          MIB.getInstr()->setCFIFlag(MachineInstr::checkTag);
          MI_I->setCFIFlag(MachineInstr::checkedCall);
          placeTag(MI_I, MBB, DL, Fn, CFITid);

          MachineBasicBlock* ErrorMBB = getOrAddCCFIErrorMBB(Fn);
          MIB = BuildMI(MBB, MI_I, DL, TII.get(X86::JNE_1)).addMBB(ErrorMBB);
          MIB.getInstr()->setCFIFlag(MachineInstr::errorLoop);

          if(PtrCall){
            MIB = BuildMI(MBB, MI_I, DL, TII.get(X86::CALL64r));
            MIB.addReg(CFIReg);
            MIB.getInstr()->setCFIFlag(MachineInstr::checkedCall);
            MI.removeFromParent();
          }

          MBB.addSuccessor(ErrorMBB);
          ErrorMBB->transferSuccessorsAndUpdatePHIs(&MBB);
        } else {
          // no need to worry about tailjmps here.
          if(MI.getOpcode() == X86::TAILJMPd64
             || MI.getOpcode() == X86::TAILJMPd64_REX){
            continue;
          }

          // this else checks if direct call is aliased, cloned by CGD or asm
          CFINode ni;
          CFIEdge ei;
          CFICluster ci;
          uint32_t tag = 0;
          const Function *call_tgt;
          const Function *Fc = NULL;
          for(unsigned int i = 0; i < MI.getNumOperands(); i++){
            call_tgt = dyn_cast_or_null<Function>(MI.getOperand(i).getGlobal());
            if(call_tgt) break;
          }
          if(!call_tgt){
            u.error("could not retrieve call target", true);
          }
          const GlobalValue *GV = NULL;
          if(CFICGD && !cfi.getAsmNode(call_tgt).id){
            std::stringstream new_dst;
            new_dst << call_tgt->getName().str() << "_kcfi";
            GV = M->getNamedValue(new_dst.str());
            if(!GV){
              std::string alias;
              alias = cfi.checkWeakAlias(call_tgt);
              // if the symbol is an alias, we translate it to the aliasee
              // this aliasee symbol was created on CFI.cpp
              if(alias.length()>0){
                new_dst.str(std::string());
                new_dst.clear();
                new_dst << alias << "_kcfi";
                GV = M->getNamedValue(new_dst.str());
              }
            }
          }
          if(GV){
            MIB = BuildMI(MBB, MI_I, DL, TII.get(MI.getOpcode()));
            MIB.addGlobalAddress(GV);
            for(unsigned int i = 1; i < MI.getNumOperands(); i++){
              MachineOperand MOp = MI.getOperand(i);
              MIB.addOperand(MOp);
            }
            MIB.getInstr()->setCFIFlag(MachineInstr::checkedCall);
            if(CFICGD){
              if(!Fc) Fc = Fn.getFunction();
              ei = cfi.getEdge(Fc, call_tgt);
              ni = cfi.getNode(ei.target);
              tag = ni.tail_id;
            }
          } else {
            if(!CFICGD){
              std::string aliasee = cfi.checkWeakAlias(call_tgt);
              if(aliasee.length() > 0){
                if(CFIvv){
                  cfi_warn << "CFI: Aliasee found ";
                  cfi_warn << Fn.getFunction()->getName().str();
                  cfi_warn << " " << aliasee;
                  u.warn();
                }
                ni = cfi.getNodeBinary(Fn.getFunction(), aliasee);
                ci = cfi.getCluster(ni.proto);
                tag = ci.tail_id;
              } else {
                ci = cfi.getCluster(call_tgt->getFunctionType());
                tag = ci.tail_id;
              }
            }
            if(tag == 0){
              if(!Fc) Fc = Fn.getFunction();
              ei = cfi.getEdge(Fc, call_tgt);
              ni = cfi.getNode(ei.target);
              tag = ni.tail_id;
              if(cfi.getAsmNode(call_tgt).id){
                if(!cfi.loadedDecls()) cfi.loadDecls();
                std::string p = cfi.getDeclProto(call_tgt->getName());
                ci = cfi.getCluster(p);
                if(ci.id) tag = ci.tail_id;
              }
            }
          }
          if(tag == 0){
            // sometimes this happens because code being compiled will be
            // inlined, and this masks the edge for the static analysis
            ni = cfi.getNode(call_tgt, false);
            if(cfi.checkDuplicates(ni)){
              if(CFIvv) dbgs() << "Duplicated target with hidden edge found\n";
              ni = cfi.getNodeBinary(call_tgt->getName());
              if(!ni.id){
                if(CFIvv){
                  dbgs() << call_tgt->getName();
                  dbgs() << " Marking call on code with tag 0x1337beef\n";
                }
                tag = 0x1337beef;
              } else {
                tag = ni.tail_id;
              }
            } else {
              if(CFIvv){
                dbgs() << "Hidden edge for node: ";
                dbgs() << call_tgt->getName() << "\n";
              }
              tag = ni.tail_id;
            }
          }
          if(tag == 0){
            cfi_warn << "Something went wrong!";
            cfi_warn << "Unmatched call tagged with 0x1337beef!";
            u.warn();
            tag = 0x1337beef;
          }
          placeTag(MI_I, MBB, DL, Fn, tag);
          if(GV) MI.removeFromParent();
          else MI.setCFIFlag(MachineInstr::checkedCall);
        }
        MI_I = MBB.begin();
      }
    }
  }
}

void CFIInstrumentation::doRets(MachineFunction &Fn,
                                MachineFunction::iterator FI,
                                MachineBasicBlock &MBB){
  if(CFIBuildCFG || CFINoChecks) return;
  unsigned TagOffset = 4;
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const X86RegisterInfo *RegInfo = STI.getRegisterInfo();
  DebugLoc DL;
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  unsigned BasePtr = RegInfo->getStackRegister();
  unsigned int CFITid = 0;

  // keep main here to support tests on user-space code
  StringRef mainName = "main";
  if(Fn.getName().equals_lower(mainName)) return;

  const Function *F = Fn.getFunction();

  CFINode n = cfi.getNode(F->getCFINode());
  if(!n.id){
    cfi_er << "CFINode doesn't exist: " << F->getName().str();
    u.error(true);
  }
  CFICluster c = cfi.getCluster(F->getCFICluster());
  if(c.id) CFITid = c.tail_id;
  else CFITid = n.tail_id;
  if(CFITid == 0){
    u.error("Error retrieving return tag for instruction", true);
  }

  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
  if(MBBI->getCFIFlag() == MachineInstr::checkedRet) return;

  MachineInstrBuilder MIB;

  // kCFI has no support to tailjmps
  unsigned Opcode = MBBI->getOpcode();
  if(Opcode == X86::TAILJMPr64 || Opcode == X86::TAILJMPd64 ||
     Opcode == X86::TAILJMPm64 || Opcode == X86::TAILJMPd64_REX ||
     Opcode == X86::TAILJMPr64_REX || Opcode == X86::TAILJMPm64_REX){
    return;
  }

  unsigned Movrm;
  if(STI.is64Bit()){
    Movrm = X86::MOV64rm;
  } else {
    Movrm = X86::MOV32rm;
  }

  if(!CFINoChecks){
    // Load Return Address
    MIB = BuildMI(MBB, MBBI, DL, TII.get(Movrm), CFIReg);
    addRegOffset(MIB, BasePtr, false, 0);
    MIB.getInstr()->setCFIFlag(MachineInstr::loadPtrToRet);

    MBBI->setCFIFlag(MachineInstr::checkedRet);
    MachineBasicBlock *CFIErrorMBB = getOrAddRCFIErrorMBB(Fn);

    StringRef fname = Fn.getName();

    MachineBasicBlock *GuardMBB = &MBB;
    MachineBasicBlock *GuardMBB2;
    int more_ids = cfi.getSecondaryIds(fname);

    for(int i = 0; i < more_ids; i++){
      unsigned int sid = cfi.getSecondaryId(fname, i);

      GuardMBB2 = Fn.CreateMachineBasicBlock();
      Fn.insert(Fn.end(), GuardMBB2);

      addSecondaryCFICheck(Fn, GuardMBB, MBBI, GuardMBB2, sid, TagOffset);
      GuardMBB->addSuccessor(GuardMBB2);

      GuardMBB = GuardMBB2;
      MIB = BuildMI(*GuardMBB, GuardMBB->begin(), DL, TII.get(X86::RETQ));
      MIB.getInstr()->setCFIFlag(MachineInstr::checkedRet);
      MBBI = GuardMBB->begin();
    }

    // Compare CFI Tag
    MIB = BuildMI(*GuardMBB, MBBI, DL, TII.get(X86::CMP32mi));
    addRegOffset(MIB, CFIReg, true, TagOffset);
    MIB.addImm(CFITid);
    MIB.getInstr()->setCFIFlag(MachineInstr::checkTag);

    MIB = BuildMI(*GuardMBB, MBBI, DL, TII.get(X86::JNE_1)).addMBB(CFIErrorMBB);
    MIB.getInstr()->setCFIFlag(MachineInstr::errorLoop);

    MBB.addSuccessor(CFIErrorMBB);
    CFIErrorMBB->transferSuccessorsAndUpdatePHIs(GuardMBB);
  }
  return;
}

void CFIInstrumentation::placeTag(MachineBasicBlock::iterator MI_I,
                                  MachineBasicBlock &MBBx,
                                  DebugLoc DL,
                                  MachineFunction &Fn, unsigned int cfitag){

  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();

  MachineInstrBuilder MIB;

  ++MI_I;

  MIB = BuildMI(MBBx, MI_I, DL, TII.get(X86::NOOPL))
    .addReg(0)
    .addImm(1)
    .addReg(0)
    .addImm(cfitag)
    .addReg(0);
  MIB.getInstr()->setCFIFlag(MachineInstr::tag);
  return;
}

using namespace std;

list<int> CFIInstrumentation::isWL(list<string> WhiteList, string fname){
  string word;
  list<int> Skips;
  for(list<string>::iterator i = WhiteList.begin();
      i != WhiteList.end();
      ++i){
    istringstream iss(*i, istringstream::in);
    iss >> word;
    if(word.compare(fname)==0){
      while(iss >> word){
        Skips.push_back(std::stoi(word, nullptr, 10));
      }
    }
  }
  return Skips;
}

bool CFIInstrumentation::shouldSkip(list<int> SkipList, int SkipN){
  list<int>::iterator skip_it;
  skip_it = find(SkipList.begin(), SkipList.end(), SkipN);
  if(skip_it != SkipList.end())
    return true;
  else
    return false;
}

void CFIInstrumentation::doCallsCoarse(MachineFunction &Fn){
  StringRef fname = Fn.getName();
  int TagOffset = -4;
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  DebugLoc DL;
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  bool PtrCall = true;
  bool IndirectCall = false;
  bool ShouldKill;
  unsigned Dst = 0;
  unsigned NumParms = 1;
  uint32_t tag = 0x1337beef;

  std::list<int> ICallSkips;
  std::list<int>::iterator skip_it;

  MachineBasicBlock::iterator MI_I, MI_IE;
  MachineFunction::iterator MBB_I, MBB_IE;
  MachineFunction::iterator Entry = *Fn.begin();
  while(Entry->empty()){
    Entry++;
    if(Entry == Fn.end() && CFIv){
      cfi_warn << "CFIWarn: Empty function found: " << fname.str() << "\n";
      u.warn();
      return;
    }
  }
  MI_I = Entry->begin();

  unsigned Movrm;
  if(STI.is64Bit()){
    Movrm = X86::MOV64rm;
  } else {
    Movrm = X86::MOV32rm;
  }

  MachineInstrBuilder MIB;
  for(MBB_I = Fn.begin(), MBB_IE = Fn.end(); MBB_I != MBB_IE; MBB_I++) {
    MachineBasicBlock &MBB = *MBB_I;
    for(MI_I = MBB.begin(), MI_IE = MBB.end(); MI_I != MI_IE; MI_I++) {
      MachineInstr &MI = *MI_I;
      unsigned Opc = MI.getOpcode();

      if(MI.isCall() && MI.getCFIFlag() != MachineInstr::checkedCall){
        DL = MI.getDebugLoc();
        IndirectCall = false;
        PtrCall = true;
        ShouldKill = false;
        NumParms = 1;
        unsigned int NumOps = MI.getNumOperands();

        if(NumOps > 0){
          MachineOperand Op = MI.getOperand(0);
          if(Op.isSymbol()){
            std::string s = Op.getSymbolName();
            if(s.compare("memcpy")==0 || s.compare("memset")==0){
              placeTag(MI_I, MBB, DL, Fn, 0x1337beef);
              MI.setCFIFlag(MachineInstr::checkedCall);
              continue;
            }
            cfi_warn << "UNHANDLED SYMBOL: " << s << " ";
            cfi_warn << Fn.getFunction()->getParent()->getName().str() << "\n";
            u.warn();
          };
          if(Op.isGlobal()){}
          else if(Op.isReg()){
            Dst = Op.getReg();
            IndirectCall = true;
            if(Opc == X86::CALL64m || Opc == X86::CALL32m){
              Op = MI.getOperand(2);
              NumParms = 5;
            } else if(MI.getOpcode() == X86::TAILJMPm64){
              continue;
            } else {
              PtrCall = false;
              NumParms = 1;
            }
          } else if(Op.isFI()){
            IndirectCall = true;
            NumParms = 5;
          } else if(NumOps >= 2 && MI.getOperand(2).isReg()
                    && MI.getOperand(3).isGlobal()){
            Op = MI.getOperand(2);
            Dst = Op.getReg();
            IndirectCall = true;
            NumParms = 5;
          }
        }

        if(IndirectCall && !CFINoChecks) {
          if(PtrCall){
            MIB = BuildMI(MBB, MI_I, DL, TII.get(Movrm), CFIReg);

            for(unsigned i = 0; i < MI.getNumOperands() && i < NumParms; i++){
              MIB.addOperand(MI.getOperand(i));
              if(MIB.getInstr()->getOperand(i).isReg()
                 && !MIB.getInstr()->getOperand(i).isDef())
                MIB.getInstr()->getOperand(i).setIsKill(false);
            }
            Dst = CFIReg;
            ShouldKill = true;
          }
          MIB = BuildMI(MBB, MI_I, DL, TII.get(X86::CMP32mi));
          addRegOffset(MIB, Dst, ShouldKill, TagOffset);
          MIB.addImm(tag);
          MIB.getInstr()->setCFIFlag(MachineInstr::checkTag);
          MI_I->setCFIFlag(MachineInstr::checkedCall);
          placeTag(MI_I, MBB, DL, Fn, tag);

          MachineBasicBlock* ErrorMBB = getOrAddCCFIErrorMBB(Fn);
          MIB = BuildMI(MBB, MI_I, DL, TII.get(X86::JNE_1)).addMBB(ErrorMBB);
          MIB.getInstr()->setCFIFlag(MachineInstr::errorLoop);

          MBB.addSuccessor(ErrorMBB);
          ErrorMBB->transferSuccessorsAndUpdatePHIs(&MBB);
        } else {
          if(MI.getOpcode() == X86::TAILJMPd64 ||
             MI.getOpcode() == X86::TAILJMPd64_REX){
            continue;
          }
          placeTag(MI_I, MBB, DL, Fn, tag);
          MI.setCFIFlag(MachineInstr::checkedCall);
        }
        MI_I = MBB.begin();
      }
    }
  }
  return;
}

void CFIInstrumentation::doRetsCoarse(MachineFunction &Fn,
                                MachineFunction::iterator FI,
                                MachineBasicBlock &MBB){
  if(CFIBuildCFG || CFINoChecks) return;
  unsigned TagOffset = 4;
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const X86RegisterInfo *RegInfo = STI.getRegisterInfo();
  DebugLoc DL;
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  unsigned BasePtr = RegInfo->getStackRegister();
  uint32_t tag = 0x1337beef;

  StringRef mainName = "main";
  if(Fn.getName().equals_lower(mainName)) return;

  MachineBasicBlock::iterator MBBI = MBB.getLastNonDebugInstr();
  if(MBBI->getCFIFlag() == MachineInstr::checkedRet) return;

  MachineInstrBuilder MIB;

  unsigned Opcode = MBBI->getOpcode();
  if(Opcode == X86::TAILJMPr64 || Opcode == X86::TAILJMPd64 ||
     Opcode == X86::TAILJMPm64 || Opcode == X86::TAILJMPd64_REX ||
     Opcode == X86::TAILJMPr64_REX || Opcode == X86::TAILJMPm64_REX){
    return;
  }

  unsigned Movrm;
  if(STI.is64Bit()){
    Movrm = X86::MOV64rm;
  } else {
    Movrm = X86::MOV32rm;
  }

  if(!CFINoChecks){
    MIB = BuildMI(MBB, MBBI, DL, TII.get(Movrm), CFIReg);
    addRegOffset(MIB, BasePtr, false, 0);
    MIB.getInstr()->setCFIFlag(MachineInstr::loadPtrToRet);

    MBBI->setCFIFlag(MachineInstr::checkedRet);
    MachineBasicBlock *CFIErrorMBB = getOrAddRCFIErrorMBB(Fn);

    // Compare CFI Tag
    MIB = BuildMI(MBB, MBBI, DL, TII.get(X86::CMP32mi));
    addRegOffset(MIB, CFIReg, true, TagOffset);
    MIB.addImm(tag);
    MIB.getInstr()->setCFIFlag(MachineInstr::checkTag);

    MIB = BuildMI(MBB, MBBI, DL, TII.get(X86::JNE_1)).addMBB(CFIErrorMBB);
    MIB.getInstr()->setCFIFlag(MachineInstr::errorLoop);

    MBB.addSuccessor(CFIErrorMBB);
    CFIErrorMBB->transferSuccessorsAndUpdatePHIs(&MBB);
  }
}

MachineBasicBlock* CFIInstrumentation::getOrAddCCFIErrorMBB(MachineFunction &Fn)
{
  MachineModuleInfo &MMI = Fn.getMMI();
  const Module *M = MMI.getModule();
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const X86RegisterInfo *RegInfo = STI.getRegisterInfo();
  const uint32_t *RegMask = RegInfo->getCallPreservedMask(Fn, CallingConv::C);
  unsigned Callr = X86::CALL64pcrel32;
  DebugLoc DL;

  MachineBasicBlock* ErrorMBB = Fn.getCallCFIErrorMBB();
  if(ErrorMBB) return ErrorMBB;

  ErrorMBB = Fn.CreateMachineBasicBlock();
  //Fn.insert(Fn.end(), ErrorMBB);
  Fn.push_back(ErrorMBB);
  Fn.setCallCFIErrorMBB(ErrorMBB);

  MachineInstrBuilder MIB;
  MIB = BuildMI(*ErrorMBB, ErrorMBB->begin(), DL, TII.get(Callr))
    .addGlobalAddress(M->getNamedValue("call_violation_handler"))
    .addRegMask(RegMask);
  MIB.getInstr()->setCFIFlag(MachineInstr::checkedCall);

  return ErrorMBB;
}

MachineBasicBlock* CFIInstrumentation::getOrAddRCFIErrorMBB(MachineFunction &Fn)
{
  MachineModuleInfo &MMI = Fn.getMMI();
  const Module *M = MMI.getModule();
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  const X86RegisterInfo *RegInfo = STI.getRegisterInfo();
  const uint32_t *RegMask = RegInfo->getCallPreservedMask(Fn, CallingConv::C);
  unsigned Callr = X86::CALL64pcrel32;
  DebugLoc DL;

  MachineBasicBlock* ErrorMBB = Fn.getRetCFIErrorMBB();
  if(ErrorMBB) return ErrorMBB;

  ErrorMBB = Fn.CreateMachineBasicBlock();
  Fn.push_back(ErrorMBB);
  Fn.setRetCFIErrorMBB(ErrorMBB);

  MachineInstrBuilder MIB;
  MIB = BuildMI(*ErrorMBB, ErrorMBB->begin(), DL, TII.get(Callr))
    .addGlobalAddress(M->getNamedValue("ret_violation_handler"))
    .addRegMask(RegMask);
  MIB.getInstr()->setCFIFlag(MachineInstr::checkedCall);

  return ErrorMBB;
}

void CFIInstrumentation::addSecondaryCFICheck(MachineFunction &Fn,
                                              MachineBasicBlock *GuardMBB1,
                                              MachineBasicBlock::iterator MBBI,
                                              MachineBasicBlock *GuardMBB2,
                                              unsigned Tag, unsigned Offset)
{
  const X86Subtarget &STI = Fn.getSubtarget<X86Subtarget>();
  const TargetInstrInfo &TII = *STI.getInstrInfo();
  DebugLoc DL;

  MachineBasicBlock* TargetMBB;
  if (GuardMBB2) TargetMBB = GuardMBB2;
  else TargetMBB = getOrAddRCFIErrorMBB(Fn);

  MachineInstrBuilder MIB;
  MIB = BuildMI(*GuardMBB1, MBBI, DL, TII.get(X86::CMP32mi));
  addRegOffset(MIB, CFIReg, true, Offset);
  MIB.addImm(Tag);
  MIB.getInstr()->setCFIFlag(MachineInstr::checkTag);

  MIB = BuildMI(*GuardMBB1, MBBI, DL, TII.get(X86::JNE_1)).addMBB(TargetMBB);
  MIB.getInstr()->setCFIFlag(MachineInstr::errorLoop);

  GuardMBB1->addSuccessor(TargetMBB);
  TargetMBB->transferSuccessorsAndUpdatePHIs(GuardMBB1);
}
